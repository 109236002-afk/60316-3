<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç°¡æ˜“å¡”é˜²éŠæˆ²</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: #1e1e1e; /* æ·±è‰²èƒŒæ™¯ */
            color: #e0e0e0;
            margin: 0;
            padding: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        /* éŠæˆ²å®¹å™¨ */
        #game-container {
            max-width: 800px;
            width: 100%;
            margin: 0 auto; /* æ°´å¹³ç½®ä¸­ */
            background-color: #2d2d2d;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* ä¿æŒç•«å¸ƒé•·å¯¬æ¯”çš„åŒ…è£¹å™¨ (800x480 = 10:6 = 100:60) */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            padding-top: 60%; /* 60% = 480 / 800 * 100% */
            background-color: #000;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #5a8c49; /* è‰åœ°é¡è‰² */
            border-bottom: 2px solid #444;
        }

        /* UI é¢æ¿ */
        #ui-panel {
            padding: 16px;
            background-color: #3a3a3a;
            border-top: 2px solid #444;
        }

        #stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 16px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        #stats span {
            padding: 8px 12px;
            background-color: #4a4a4a;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3) inset;
            min-width: 80px;
            text-align: center;
        }

        #controls {
            display: flex;
            flex-wrap: wrap; /* å…è¨±æŒ‰éˆ•æ›è¡Œ */
            gap: 12px;
            justify-content: center;
        }

        button {
            font-family: inherit;
            font-size: 1rem;
            font-weight: 600;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #5c5c5c;
            color: #ffffff;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            flex-grow: 1; /* æŒ‰éˆ•è‡ªå‹•å¡«æ»¿ç©ºé–“ */
            min-width: 150px; /* æœ€å°å¯¬åº¦ */
        }

        button.start-wave {
            background-color: #4CAF50; /* ç¶ è‰² */
        }
        
        button.tower-buy {
            background-color: #008CBA; /* è—è‰² */
        }
        
        button.tower-buy.selected,
        button.tower-buy:hover:not(:disabled) {
            background-color: #00aeff;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            background-color: #757575;
            color: #b0b0b0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* éŠæˆ²çµæŸ/ç²å‹å½ˆçª— */
        #popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 40px;
            border-radius: 16px;
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            display: none; /* é è¨­éš±è— */
            z-index: 100;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- ç•«å¸ƒåŒ…è£¹å™¨ -->
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="800" height="480"></canvas>
            <!-- éŠæˆ²çµæŸå½ˆçª— -->
            <div id="popup"></div>
        </div>

        <!-- UI æ§åˆ¶é¢æ¿ -->
        <div id="ui-panel">
            <div id="stats">
                <span id="money">ğŸ’° é‡‘éŒ¢: 350</span>
                <span id="lives">â¤ï¸ ç”Ÿå‘½: 20</span>
                <span id="wave">ğŸŒŠ æ³¢æ•¸: 0</span>
            </div>
            <div id="controls">
                <button id="startWaveBtn" class="start-wave">é–‹å§‹ä¸‹ä¸€æ³¢</button>
                <button id="buyTowerBtn" class="tower-buy" data-type="standard" data-cost="75">è³¼è²· ğŸ—¼ (75é‡‘)</button>
                <button id="buyRapidTowerBtn" class="tower-buy" data-type="rapid" data-cost="125">è³¼è²· âš¡ (125é‡‘)</button>
                <button id="buySplashTowerBtn" class="tower-buy" data-type="splash" data-cost="175">è³¼è²· ğŸ’¥ (175é‡‘)</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // UI å…ƒç´ 
            const moneyEl = document.getElementById('money');
            const livesEl = document.getElementById('lives');
            const waveEl = document.getElementById('wave');
            const startWaveBtn = document.getElementById('startWaveBtn');
            const buyTowerBtns = document.querySelectorAll('.tower-buy');
            const popupEl = document.getElementById('popup');

            const TILE_SIZE = 40;
            const COLS = canvas.width / TILE_SIZE; // 800 / 40 = 20
            const ROWS = canvas.height / TILE_SIZE; // 480 / 40 = 12

            let money = 350;
            let lives = 20;
            let wave = 0;
            let gameRunning = true;

            const enemies = [];
            const towers = [];
            const projectiles = [];
            const explosions = []; // ç”¨æ–¼ç¯„åœå‚·å®³çš„çˆ†ç‚¸æ•ˆæœ

            // æ•µäººè·¯å¾‘ (x, y åº§æ¨™)
            const waypoints = [
                { x: 0, y: 5 }, { x: 3, y: 5 }, { x: 3, y: 2 }, { x: 7, y: 2 }, { x: 7, y: 8 },
                { x: 12, y: 8 }, { x: 12, y: 3 }, { x: 17, y: 3 }, { x: 17, y: 10 }, { x: 20, y: 10 }
            ].map(p => ({ x: (p.x * TILE_SIZE) + (TILE_SIZE / 2), y: (p.y * TILE_SIZE) + (TILE_SIZE / 2) }));

            // éŠæˆ²ç¶²æ ¼ (0: è‰åœ°, 1: è·¯å¾‘)
            const grid = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));

            // ç¹ªè£½è·¯å¾‘åˆ°ç¶²æ ¼
            function buildPathGrid() {
                ctx.lineWidth = TILE_SIZE * 0.8; // è·¯å¾‘å¯¬åº¦
                ctx.strokeStyle = '#a0522d'; // æ£•è‰²
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x, waypoints[0].y);
                
                // æ¨™è¨˜è·¯å¾‘æ ¼
                function setGridPath(x, y) {
                    const gridX = Math.floor(x / TILE_SIZE);
                    const gridY = Math.floor(y / TILE_SIZE);
                    if (grid[gridY] && grid[gridY][gridX] !== undefined) {
                        grid[gridY][gridX] = 1; // 1 ä»£è¡¨è·¯å¾‘
                    }
                }

                for (let i = 1; i < waypoints.length; i++) {
                    const prev = waypoints[i - 1];
                    const curr = waypoints[i];
                    ctx.lineTo(curr.x, curr.y);

                    // æ¨™è¨˜è·¯å¾‘ä¸Šçš„æ ¼å­
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const steps = Math.max(Math.abs(dx), Math.abs(dy)) / (TILE_SIZE / 4);
                    
                    for (let j = 0; j <= steps; j++) {
                        const x = prev.x + (dx * j / steps);
                        const y = prev.y + (dy * j / steps);
                        setGridPath(x, y);
                        setGridPath(x - TILE_SIZE * 0.4, y - TILE_SIZE * 0.4);
                        setGridPath(x + TILE_SIZE * 0.4, y + TILE_SIZE * 0.4);
                        setGridPath(x - TILE_SIZE * 0.4, y + TILE_SIZE * 0.4);
                        setGridPath(x + TILE_SIZE * 0.4, y - TILE_SIZE * 0.4);
                    }
                }
                ctx.stroke();
            }

            // ç¹ªè£½ç¶²æ ¼èƒŒæ™¯ (è·¯å¾‘å’Œè‰åœ°)
            function drawBackground() {
                // ç¹ªè£½è‰åœ° (é è¨­èƒŒæ™¯è‰²)
                ctx.fillStyle = '#5a8c49';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ç¹ªè£½è·¯å¾‘
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = TILE_SIZE * 0.9;
                ctx.strokeStyle = '#a0522d'; // è·¯å¾‘é¡è‰²
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x - TILE_SIZE, waypoints[0].y); // å¾è¢å¹•å¤–é–‹å§‹
                for (let i = 0; i < waypoints.length; i++) {
                    ctx.lineTo(waypoints[i].x, waypoints[i].y);
                }
                ctx.stroke();

                ctx.lineWidth = TILE_SIZE * 0.7;
                ctx.strokeStyle = '#c27d53'; // è·¯å¾‘å…§å±¤é¡è‰²
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x - TILE_SIZE, waypoints[0].y);
                 for (let i = 0; i < waypoints.length; i++) {
                    ctx.lineTo(waypoints[i].x, waypoints[i].y);
                }
                ctx.stroke();
            }

            // åˆå§‹åŒ–ç¶²æ ¼
            buildPathGrid();

            // æ•µäºº
            class Enemy {
                constructor() {
                    this.x = waypoints[0].x - TILE_SIZE; // å¾å·¦å´è¢å¹•å¤–é–‹å§‹
                    this.y = waypoints[0].y;
                    this.radius = 12;
                    this.waypointIndex = 0;
                    this.speed = 1.5 + (wave * 0.1); // é€Ÿåº¦éš¨æ³¢æ¬¡å¢åŠ 
                    this.maxHealth = Math.floor(15 + wave * 5 + Math.pow(wave, 1.2)); // è¡€é‡éš¨æ³¢æ¬¡å¢åŠ 
                    this.health = this.maxHealth;
                    this.value = 5 + wave; // æ“Šæ®ºé‡‘éŒ¢
                }

                update() {
                    if (this.waypointIndex >= waypoints.length) {
                        return; // å·²é”çµ‚é»
                    }

                    const target = waypoints[this.waypointIndex];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.speed) {
                        this.x = target.x;
                        this.y = target.y;
                        this.waypointIndex++;
                        if (this.waypointIndex >= waypoints.length) {
                            this.reachEnd();
                        }
                    } else {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                }

                draw() {
                    // ç¹ªè£½æ•µäºº
                    ctx.font = '24px Arial';
                    ctx.fillText('ğŸ‘¾', this.x - this.radius, this.y + this.radius / 2);

                    // ç¹ªè£½è¡€æ¢
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius - 8, this.radius * 2, 5);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius - 8, (this.radius * 2) * (this.health / this.maxHealth), 5);
                }

                takeDamage(amount) {
                    this.health -= amount;
                    if (this.health <= 0) {
                        this.die();
                        return true; // æ­»äº¡
                    }
                    return false; // å­˜æ´»
                }

                die() {
                    money += this.value;
                    const index = enemies.indexOf(this);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                }

                reachEnd() {
                    lives--;
                    const index = enemies.indexOf(this);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                    if (lives <= 0) {
                        gameOver();
                    }
                }
            }

            // é˜²ç¦¦å¡”
            const towerTypes = {
                standard: {
                    emoji: 'ğŸ—¼',
                    range: 120,
                    fireRate: 60, // 60å¹€ = 1ç§’
                    projectile: { speed: 5, damage: 10, color: 'cyan' },
                    cost: 75
                },
                rapid: {
                    emoji: 'âš¡',
                    range: 100,
                    fireRate: 20, // å°„é€Ÿå¿«
                    projectile: { speed: 6, damage: 4, color: 'yellow' },
                    cost: 125
                },
                splash: {
                    emoji: 'ğŸ’¥',
                    range: 140,
                    fireRate: 100, // å°„é€Ÿæ…¢
                    projectile: { speed: 3, damage: 15, color: 'orange', splashRadius: 40 },
                    cost: 175
                }
            };

            class Tower {
                constructor(x, y, type) {
                    this.x = (x * TILE_SIZE) + (TILE_SIZE / 2);
                    this.y = (y * TILE_SIZE) + (TILE_SIZE / 2);
                    this.type = type;
                    const specs = towerTypes[type];
                    this.emoji = specs.emoji;
                    this.range = specs.range;
                    this.fireRate = specs.fireRate;
                    this.projectileSpec = specs.projectile;
                    this.fireCooldown = 0;
                    this.target = null;
                }

                findTarget() {
                    // AI é‚è¼¯ï¼šå„ªå…ˆæ”»æ“Šè·¯å¾‘ä¸Šèµ°æœ€é  (waypointIndex æœ€å¤§) çš„æ•µäºº
                    // å¦‚æœ waypointIndex ç›¸åŒï¼Œå‰‡æ”»æ“Šæœ€æ¥è¿‘ä¸‹ä¸€å€‹ wayppoint çš„æ•µäºº
                    let bestTarget = null;
                    let maxWaypointIndex = -1;
                    let minDistanceToNext = Infinity;

                    for (const enemy of enemies) {
                        const distance = Math.sqrt(Math.pow(this.x - enemy.x, 2) + Math.pow(this.y - enemy.y, 2));

                        if (distance <= this.range) {
                            if (enemy.waypointIndex > maxWaypointIndex) {
                                // æ‰¾åˆ°ä¸€å€‹èµ°å¾—æ›´é çš„æ•µäºº
                                maxWaypointIndex = enemy.waypointIndex;
                                bestTarget = enemy;
                                
                                // è¨ˆç®—åˆ°ä¸‹ä¸€å€‹ç›®æ¨™é»çš„è·é›¢
                                if (enemy.waypointIndex < waypoints.length) {
                                    const nextWp = waypoints[enemy.waypointIndex];
                                    const dx = nextWp.x - enemy.x;
                                    const dy = nextWp.y - enemy.y;
                                    minDistanceToNext = Math.sqrt(dx * dx + dy * dy);
                                } else {
                                    minDistanceToNext = Infinity; // å·²é”çµ‚é»
                                }

                            } else if (enemy.waypointIndex === maxWaypointIndex) {
                                //  waypointIndex ç›¸åŒï¼Œæ¯”è¼ƒèª°é›¢ä¸‹å€‹é»è¿‘
                                if (enemy.waypointIndex < waypoints.length) {
                                    const nextWp = waypoints[enemy.waypointIndex];
                                    const dx = nextWp.x - enemy.x;
                                    const dy = nextWp.y - enemy.y;
                                    const distToNext = Math.sqrt(dx * dx + dy * dy);

                                    if (distToNext < minDistanceToNext) {
                                        minDistanceToNext = distToNext;
                                        bestTarget = enemy;
                                    }
                                }
                            }
                        }
                    }
                    this.target = bestTarget;
                }

                update() {
                    if (this.fireCooldown > 0) {
                        this.fireCooldown--;
                    }

                    // æª¢æŸ¥ç›®å‰ç›®æ¨™æ˜¯å¦æœ‰æ•ˆ
                    if (this.target) {
                        const distance = Math.sqrt(Math.pow(this.x - this.target.x, 2) + Math.pow(this.y - this.target.y, 2));
                        // å¦‚æœç›®æ¨™æ­»äº¡ (health <= 0) æˆ–è¶…å‡ºç¯„åœ
                        if (this.target.health <= 0 || distance > this.range) {
                            this.target = null;
                        }
                    }
                    
                    // å¦‚æœæ²’æœ‰ç›®æ¨™ï¼Œå°‹æ‰¾æ–°ç›®æ¨™
                    if (!this.target) {
                        this.findTarget();
                    }

                    // å¦‚æœæœ‰ç›®æ¨™ä¸”å†·å»å®Œç•¢
                    if (this.target && this.fireCooldown <= 0) {
                        this.shoot();
                        this.fireCooldown = this.fireRate;
                    }
                }

                draw() {
                    ctx.font = '28px Arial';
                    ctx.fillText(this.emoji, this.x - TILE_SIZE / 2 + 5, this.y + TILE_SIZE / 2 - 8);

                    // ç¹ªè£½æ”»æ“Šç¯„åœ (åƒ…åœ¨é è¦½æ™‚)
                    if (placingTowerType && this.x === mouse.x && this.y === mouse.y) {
                         ctx.beginPath();
                         ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                         ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                         ctx.stroke();
                    }
                }

                shoot() {
                    projectiles.push(new Projectile(this.x, this.y, this.target, this.projectileSpec));
                }
            }

            // å­å½ˆ
            class Projectile {
                constructor(x, y, target, spec) {
                    this.x = x;
                    this.y = y;
                    this.target = target;
                    this.speed = spec.speed;
                    this.damage = spec.damage;
                    this.color = spec.color;
                    this.radius = 4;
                    this.splashRadius = spec.splashRadius || 0;
                }

                update() {
                    if (!this.target || this.target.health <= 0) {
                        this.destroy();
                        return;
                    }

                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.speed || distance < this.radius) {
                        this.hitTarget();
                        return;
                    }

                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                hitTarget() {
                    if (this.splashRadius > 0) {
                        // ç¯„åœå‚·å®³
                        explosions.push(new Explosion(this.x, this.y, this.splashRadius));
                        for (const enemy of enemies) {
                            const dist = Math.sqrt(Math.pow(this.x - enemy.x, 2) + Math.pow(this.y - enemy.y, 2));
                            if (dist <= this.splashRadius) {
                                enemy.takeDamage(this.damage);
                            }
                        }
                    } else {
                        // å–®é«”å‚·å®³
                        if (this.target) {
                            this.target.takeDamage(this.damage);
                        }
                    }
                    this.destroy();
                }

                destroy() {
                    const index = projectiles.indexOf(this);
                    if (index > -1) {
                        projectiles.splice(index, 1);
                    }
                }
            }
            
            // çˆ†ç‚¸æ•ˆæœ
            class Explosion {
                constructor(x, y, radius) {
                    this.x = x;
                    this.y = y;
                    this.radius = radius;
                    this.maxRadius = radius;
                    this.duration = 15; // æŒçºŒ 15 å¹€
                    this.life = this.duration;
                }
                
                update() {
                    this.life--;
                    if(this.life <= 0) {
                        const index = explosions.indexOf(this);
                        if (index > -1) {
                            explosions.splice(index, 1);
                        }
                    }
                }
                
                draw() {
                    const opacity = this.life / this.duration;
                    this.radius = this.maxRadius * (1 - opacity); // å¾å°è®Šå¤§
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 165, 0, ${opacity * 0.5})`;
                    ctx.fill();
                }
            }

            // éŠæˆ²é‚è¼¯
            let waveInProgress = false;

            function startWave() {
                if (waveInProgress) return;
                waveInProgress = true;
                wave++;
                startWaveBtn.disabled = true;

                const enemyCount = 10 + wave * 3;
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        if (gameRunning) {
                            enemies.push(new Enemy());
                        }
                    }, i * 500); // æ¯ 0.5 ç§’å‡ºä¸€éš»æ€ª
                }

                // æª¢æŸ¥æ³¢æ¬¡æ˜¯å¦çµæŸ
                const checkWaveEnd = setInterval(() => {
                    if (enemies.length === 0 && gameRunning) {
                        waveInProgress = false;
                        startWaveBtn.disabled = false;
                        clearInterval(checkWaveEnd);
                    }
                }, 1000);
            }

            function updateUI() {
                moneyEl.textContent = `ğŸ’° é‡‘éŒ¢: ${money}`;
                livesEl.textContent = `â¤ï¸ ç”Ÿå‘½: ${lives}`;
                waveEl.textContent = `ğŸŒŠ æ³¢æ•¸: ${wave}`;
                
                // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                buyTowerBtns.forEach(btn => {
                    btn.disabled = money < btn.dataset.cost;
                });
            }

            function gameOver() {
                if (!gameRunning) return;
                gameRunning = false;
                popupEl.textContent = "éŠæˆ²çµæŸï¼";
                popupEl.style.display = 'block';
            }

            // æ»‘é¼ /æ”¾ç½®é‚è¼¯
            let placingTowerType = null;
            let mouse = { x: 0, y: 0, gridX: 0, gridY: 0 };

            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const x = (evt.clientX - rect.left) * scaleX;
                const y = (evt.clientY - rect.top) * scaleY;
                return { x, y };
            }

            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);
                mouse.x = pos.x;
                mouse.y = pos.y;
                mouse.gridX = Math.floor(mouse.x / TILE_SIZE);
                mouse.gridY = Math.floor(mouse.y / TILE_SIZE);
            });

            canvas.addEventListener('click', () => {
                if (!placingTowerType) return;

                const cost = towerTypes[placingTowerType].cost;
                if (money >= cost && canPlaceTower(mouse.gridX, mouse.gridY)) {
                    money -= cost;
                    towers.push(new Tower(mouse.gridX, mouse.gridY, placingTowerType));
                    grid[mouse.gridY][mouse.gridX] = 2; // 2 ä»£è¡¨å¡”
                    
                    // å¦‚æœæ²’æŒ‰ä½ shiftï¼Œåªæ”¾ä¸€å€‹
                    // (é€™è£¡ç°¡åŒ–ç‚ºå§‹çµ‚å–æ¶ˆé¸å–)
                    placingTowerType = null;
                    updateBuyButtons();
                }
            });
            
            function canPlaceTower(gridX, gridY) {
                if (!grid[gridY] || grid[gridY][gridX] === undefined) return false; // è¶…å‡ºé‚Šç•Œ
                return grid[gridY][gridX] === 0; // 0 ä»£è¡¨è‰åœ°
            }

            function drawPlacementPreview() {
                if (!placingTowerType) return;

                const gridX = mouse.gridX;
                const gridY = mouse.gridY;
                
                if (gridX < 0 || gridX >= COLS || gridY < 0 || gridY >= ROWS) return;

                const x = (gridX * TILE_SIZE) + (TILE_SIZE / 2);
                const y = (gridY * TILE_SIZE) + (TILE_SIZE / 2);
                const specs = towerTypes[placingTowerType];

                // ç¹ªè£½å¡”
                ctx.globalAlpha = 0.5;
                ctx.font = '28px Arial';
                ctx.fillText(specs.emoji, x - TILE_SIZE / 2 + 5, y + TILE_SIZE / 2 - 8);
                
                // ç¹ªè£½ç¯„åœ
                ctx.beginPath();
                ctx.arc(x, y, specs.range, 0, Math.PI * 2);
                
                if (canPlaceTower(gridX, gridY)) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                } else {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                }
                ctx.stroke();
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            // æŒ‰éˆ•äº‹ä»¶
            startWaveBtn.addEventListener('click', startWave);

            buyTowerBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.dataset.type;
                    const cost = parseInt(btn.dataset.cost);
                    
                    if (placingTowerType === type) {
                        // å†æ¬¡é»æ“Šå–æ¶ˆ
                        placingTowerType = null;
                    } else if (money >= cost) {
                        placingTowerType = type;
                    }
                    updateBuyButtons();
                });
            });
            
            function updateBuyButtons() {
                buyTowerBtns.forEach(btn => {
                    if(btn.dataset.type === placingTowerType) {
                        btn.classList.add('selected');
                        btn.style.backgroundColor = '#00aeff'; // ä¿æŒé¸ä¸­é«˜äº®
                    } else {
                        btn.classList.remove('selected');
                        btn.style.backgroundColor = ''; // æ¢å¾©é è¨­
                    }
                });
            }

            // éŠæˆ²ä¸»å¾ªç’°
            function gameLoop() {
                if (!gameRunning) return;

                // 1. æ¸…é™¤ç•«å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 2. ç¹ªè£½èƒŒæ™¯
                drawBackground();

                // 3. æ›´æ–°èˆ‡ç¹ªè£½
                // æ•µäºº
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (enemies[i]) { // ç¢ºä¿å­˜åœ¨
                        enemies[i].update();
                    }
                    if (enemies[i]) { // å†æ¬¡ç¢ºä¿ (å¯èƒ½åœ¨ update ä¸­æ­»äº¡)
                        enemies[i].draw();
                    }
                }

                // å¡”
                towers.forEach(tower => {
                    tower.update();
                    tower.draw();
                });

                // å­å½ˆ
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    if (projectiles[i]) {
                        projectiles[i].update();
                    }
                    if (projectiles[i]) {
                        projectiles[i].draw();
                    }
                }
                
                // çˆ†ç‚¸
                for (let i = explosions.length - 1; i >= 0; i--) {
                     if (explosions[i]) {
                        explosions[i].update();
                    }
                    if (explosions[i]) {
                        explosions[i].draw();
                    }
                }

                // ç¹ªè£½æ”¾ç½®é è¦½
                drawPlacementPreview();

                // 4. æ›´æ–° UI
                updateUI();

                // 5. å¾ªç’°
                requestAnimationFrame(gameLoop);
            }

            // å•Ÿå‹•éŠæˆ²
            updateUI();
            drawBackground(); // åˆå§‹ç¹ªè£½ä¸€æ¬¡èƒŒæ™¯
            gameLoop();
        });
    </script>
</body>
</html>