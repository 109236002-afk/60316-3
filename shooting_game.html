<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¡”é˜²éŠæˆ²V1.1</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            background-color: #1e1e1e; /* æ·±è‰²èƒŒæ™¯ */
            color: #e0e0e0;
            margin: 0;
            padding: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        /* éŠæˆ²å®¹å™¨ */
        #game-container {
            max-width: 800px;
            width: 100%;
            margin: 0 auto; /* æ°´å¹³ç½®ä¸­ */
            background-color: #2d2d2d;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* ä¿æŒç•«å¸ƒé•·å¯¬æ¯”çš„åŒ…è£¹å™¨ (800x480 = 10:6 = 100:60) */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            padding-top: 60%; /* 60% = 480 / 800 * 100% */
            background-color: #000;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #5a8c49; /* è‰åœ°é¡è‰² */
            border-bottom: 2px solid #444;
        }

        /* UI é¢æ¿ */
        #ui-panel {
            padding: 16px;
            background-color: #3a3a3a;
            border-top: 2px solid #444;
        }

        #stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 16px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        #stats span {
            padding: 8px 12px;
            background-color: #4a4a4a;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3) inset;
            min-width: 80px;
            text-align: center;
        }

        #controls {
            display: flex;
            flex-wrap: wrap; /* å…è¨±æŒ‰éˆ•æ›è¡Œ */
            gap: 12px;
            justify-content: center;
        }

        button {
            font-family: inherit;
            font-size: 1rem;
            font-weight: 600;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #5c5c5c;
            color: #ffffff;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            flex-grow: 1; /* æŒ‰éˆ•è‡ªå‹•å¡«æ»¿ç©ºé–“ */
            min-width: 150px; /* æœ€å°å¯¬åº¦ */
            position: relative; /* ç”¨æ–¼å®šä½åƒ¹æ ¼æ¨™ç±¤ */
            overflow: hidden; /* ç¢ºä¿é€²åº¦æ¢ä¸æº¢å‡º */
        }

        button.start-wave {
            background-color: #4CAF50; /* ç¶ è‰² */
        }
        
        button.tower-buy {
            background-color: #008CBA; /* è—è‰² */
            z-index: 1;
        }
        
        button.tower-buy.selected,
        button.tower-buy:hover:not(:disabled):not(.locked):not(.unlocking) {
            background-color: #00aeff;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        /* é–å®šç‹€æ…‹çš„æŒ‰éˆ• */
        button.tower-buy.locked {
            background-color: #444;
            border: 2px dashed #666;
            color: #aaa;
        }
        button.tower-buy.locked:hover:not(.expensive) {
            background-color: #555;
            color: #fff;
            border-color: #ffd700; /* é‡‘è‰²é‚Šæ¡†æç¤ºè§£é– */
        }

        /* è§£é–ä¸­ç‹€æ…‹ */
        button.tower-buy.unlocking {
            background-color: #555;
            border: 2px solid #ffd700;
            color: #fff;
            cursor: wait;
        }
        
        /* é€²åº¦æ¢èƒŒæ™¯ */
        .progress-bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: rgba(255, 215, 0, 0.3); /* é‡‘è‰²åŠé€æ˜ */
            z-index: -1;
            transition: width 0.1s linear;
        }

        /* è‡ªå‹•å»ºé€ æŒ‰éˆ•æ¨£å¼ */
        #autoBuildBtn {
            background-color: #9c27b0; /* ç´«è‰² */
            border: 2px solid transparent;
        }
        #autoBuildBtn.active {
            background-color: #7b1fa2;
            border-color: #e1bee7;
            box-shadow: 0 0 10px #9c27b0;
        }

        button:disabled {
            background-color: #757575;
            color: #b0b0b0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* é‡‘éŒ¢ä¸è¶³æ™‚çš„æ¨£å¼ (ä¸ç¦ç”¨ï¼Œä½†è®Šç´…) */
        button.expensive {
            opacity: 0.7;
            color: #ff8888;
        }

        /* éŠæˆ²çµæŸ/ç²å‹å½ˆçª— */
        #popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 40px;
            border-radius: 16px;
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            display: none; /* é è¨­éš±è— */
            z-index: 100;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        /* æµ®å‹•è¨Šæ¯æ¨£å¼ */
        #message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 50, 50, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 101;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        
        /* æˆåŠŸè¨Šæ¯æ¨£å¼ */
        #message.success {
            background-color: rgba(50, 200, 50, 0.9);
        }
    </style>
</head>
<body>

    <div id="game-container">
        <!-- ç•«å¸ƒåŒ…è£¹å™¨ -->
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="800" height="480"></canvas>
            <!-- è¨Šæ¯æç¤º -->
            <div id="message"></div>
            <!-- éŠæˆ²çµæŸå½ˆçª— -->
            <div id="popup"></div>
        </div>

        <!-- UI æ§åˆ¶é¢æ¿ -->
        <div id="ui-panel">
            <div id="stats">
                <span id="money">ğŸ’° é‡‘éŒ¢: 450</span>
                <span id="lives">â¤ï¸ ç”Ÿå‘½: 20</span>
                <span id="wave">ğŸŒŠ æ³¢æ•¸: 0</span>
            </div>
            <div id="controls">
                <button id="startWaveBtn" class="start-wave">é–‹å§‹ä¸‹ä¸€æ³¢</button>
                <button id="buyTowerBtn" class="tower-buy" data-type="standard">è³¼è²· ğŸ—¼ (75é‡‘)</button>
                <button id="buyRapidTowerBtn" class="tower-buy" data-type="rapid">è³¼è²· âš¡ (125é‡‘)</button>
                <button id="buySplashTowerBtn" class="tower-buy" data-type="splash">è³¼è²· ğŸ’¥ (175é‡‘)</button>
                <!-- è‡ªå‹•å»ºé€ æŒ‰éˆ• -->
                <button id="autoBuildBtn">ğŸ¤– è‡ªå‹•å»ºé€ : é—œ</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // UI å…ƒç´ 
            const moneyEl = document.getElementById('money');
            const livesEl = document.getElementById('lives');
            const waveEl = document.getElementById('wave');
            const startWaveBtn = document.getElementById('startWaveBtn');
            const buyTowerBtns = document.querySelectorAll('.tower-buy');
            const autoBuildBtn = document.getElementById('autoBuildBtn');
            const popupEl = document.getElementById('popup');
            const messageEl = document.getElementById('message');

            const TILE_SIZE = 40;
            const COLS = canvas.width / TILE_SIZE; // 800 / 40 = 20
            const ROWS = canvas.height / TILE_SIZE; // 480 / 40 = 12
            const MAX_BLUEPRINTS = 10; // è—åœ–ä¸Šé™

            let money = 450;
            let lives = 20;
            let wave = 0;
            let gameRunning = true;
            let isAutoBuildOn = false; // è‡ªå‹•å»ºé€ ç‹€æ…‹

            const enemies = [];
            const towers = [];
            const projectiles = [];
            const explosions = []; // ç”¨æ–¼ç¯„åœå‚·å®³çš„çˆ†ç‚¸æ•ˆæœ

            // æ•µäººè·¯å¾‘ (x, y åº§æ¨™)
            const waypoints = [
                { x: 0, y: 5 }, { x: 3, y: 5 }, { x: 3, y: 2 }, { x: 7, y: 2 }, { x: 7, y: 8 },
                { x: 12, y: 8 }, { x: 12, y: 3 }, { x: 17, y: 3 }, { x: 17, y: 10 }, { x: 20, y: 10 }
            ].map(p => ({ x: (p.x * TILE_SIZE) + (TILE_SIZE / 2), y: (p.y * TILE_SIZE) + (TILE_SIZE / 2) }));

            // éŠæˆ²ç¶²æ ¼ (0: è‰åœ°, 1: è·¯å¾‘)
            const grid = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));

            // ç¹ªè£½è·¯å¾‘åˆ°ç¶²æ ¼
            function buildPathGrid() {
                ctx.lineWidth = TILE_SIZE * 0.8; // è·¯å¾‘å¯¬åº¦
                ctx.strokeStyle = '#a0522d'; // æ£•è‰²
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x, waypoints[0].y);
                
                // æ¨™è¨˜è·¯å¾‘æ ¼
                function setGridPath(x, y) {
                    const gridX = Math.floor(x / TILE_SIZE);
                    const gridY = Math.floor(y / TILE_SIZE);
                    if (grid[gridY] && grid[gridY][gridX] !== undefined) {
                        grid[gridY][gridX] = 1; // 1 ä»£è¡¨è·¯å¾‘
                    }
                }

                for (let i = 1; i < waypoints.length; i++) {
                    const prev = waypoints[i - 1];
                    const curr = waypoints[i];
                    ctx.lineTo(curr.x, curr.y);

                    // æ¨™è¨˜è·¯å¾‘ä¸Šçš„æ ¼å­
                    const dx = curr.x - prev.x;
                    const dy = curr.y - prev.y;
                    const steps = Math.max(Math.abs(dx), Math.abs(dy)) / (TILE_SIZE / 4);
                    
                    for (let j = 0; j <= steps; j++) {
                        const x = prev.x + (dx * j / steps);
                        const y = prev.y + (dy * j / steps);
                        setGridPath(x, y);
                        setGridPath(x - TILE_SIZE * 0.4, y - TILE_SIZE * 0.4);
                        setGridPath(x + TILE_SIZE * 0.4, y + TILE_SIZE * 0.4);
                        setGridPath(x - TILE_SIZE * 0.4, y + TILE_SIZE * 0.4);
                        setGridPath(x + TILE_SIZE * 0.4, y - TILE_SIZE * 0.4);
                    }
                }
                ctx.stroke();
            }

            // ç¹ªè£½ç¶²æ ¼èƒŒæ™¯ (è·¯å¾‘å’Œè‰åœ°)
            function drawBackground() {
                // ç¹ªè£½è‰åœ° (é è¨­èƒŒæ™¯è‰²)
                ctx.fillStyle = '#5a8c49';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ç¹ªè£½è·¯å¾‘
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = TILE_SIZE * 0.9;
                ctx.strokeStyle = '#a0522d'; // è·¯å¾‘é¡è‰²
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x - TILE_SIZE, waypoints[0].y); // å¾è¢å¹•å¤–é–‹å§‹
                for (let i = 0; i < waypoints.length; i++) {
                    ctx.lineTo(waypoints[i].x, waypoints[i].y);
                }
                ctx.stroke();

                ctx.lineWidth = TILE_SIZE * 0.7;
                ctx.strokeStyle = '#c27d53'; // è·¯å¾‘å…§å±¤é¡è‰²
                ctx.beginPath();
                ctx.moveTo(waypoints[0].x - TILE_SIZE, waypoints[0].y);
                 for (let i = 0; i < waypoints.length; i++) {
                    ctx.lineTo(waypoints[i].x, waypoints[i].y);
                }
                ctx.stroke();
            }

            // åˆå§‹åŒ–ç¶²æ ¼
            buildPathGrid();

            // æ•µäºº
            class Enemy {
                constructor() {
                    this.x = waypoints[0].x - TILE_SIZE; // å¾å·¦å´è¢å¹•å¤–é–‹å§‹
                    this.y = waypoints[0].y;
                    this.radius = 12;
                    this.waypointIndex = 0;
                    this.speed = 1.5 + (wave * 0.1); // é€Ÿåº¦éš¨æ³¢æ¬¡å¢åŠ 
                    // èª¿é™æ•µäººè¡€é‡
                    this.maxHealth = Math.floor(8 + wave * 2 + Math.pow(wave, 1.05)); // è¡€é‡éš¨æ³¢æ¬¡å¢åŠ 
                    this.health = this.maxHealth;
                    this.value = 5 + wave; // æ“Šæ®ºé‡‘éŒ¢
                }

                update() {
                    if (this.waypointIndex >= waypoints.length) {
                        return; // å·²é”çµ‚é»
                    }

                    const target = waypoints[this.waypointIndex];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.speed) {
                        this.x = target.x;
                        this.y = target.y;
                        this.waypointIndex++;
                        if (this.waypointIndex >= waypoints.length) {
                            this.reachEnd();
                        }
                    } else {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                }

                draw() {
                    // ç¹ªè£½æ•µäºº
                    ctx.font = '24px Arial';
                    ctx.fillText('ğŸ‘¾', this.x - this.radius, this.y + this.radius / 2);

                    // ç¹ªè£½è¡€æ¢
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius - 8, this.radius * 2, 5);
                    ctx.fillStyle = 'green';
                    ctx.fillRect(this.x - this.radius, this.y - this.radius - 8, (this.radius * 2) * (this.health / this.maxHealth), 5);
                }

                takeDamage(amount) {
                    this.health -= amount;
                    if (this.health <= 0) {
                        this.die();
                        return true; // æ­»äº¡
                    }
                    return false; // å­˜æ´»
                }

                die() {
                    money += this.value;
                    const index = enemies.indexOf(this);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                }

                reachEnd() {
                    lives--;
                    const index = enemies.indexOf(this);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                    if (lives <= 0) {
                        gameOver();
                    }
                }
            }

            // é˜²ç¦¦å¡”è¨­å®š
            const towerTypes = {
                standard: {
                    emoji: 'ğŸ—¼',
                    range: 120,
                    fireRate: 60, 
                    projectile: { speed: 5, damage: 10, color: 'cyan' },
                    cost: 75,
                    unlockCost: 0,
                    unlockTime: 0 // é è¨­ 0ç§’
                },
                rapid: {
                    emoji: 'âš¡',
                    range: 100,
                    fireRate: 20, 
                    projectile: { speed: 6, damage: 4, color: 'yellow' },
                    cost: 125,
                    unlockCost: 300,
                    unlockTime: 300 // 5ç§’ (60fps * 5)
                },
                splash: {
                    emoji: 'ğŸ’¥',
                    range: 140,
                    fireRate: 100, 
                    projectile: { speed: 3, damage: 15, color: 'orange', splashRadius: 40 },
                    cost: 175,
                    unlockCost: 500,
                    unlockTime: 600 // 10ç§’ (60fps * 10)
                }
            };
            
            // è¿½è¹¤å“ªäº›å¡”å·²è§£é–
            let unlockedTowers = {
                standard: true,
                rapid: false,
                splash: false
            };
            
            // è¿½è¹¤è§£é–é€²åº¦ { type: å‰©é¤˜å¹€æ•¸ }
            let unlockingTimers = {
                standard: 0,
                rapid: 0,
                splash: 0
            };

            class Tower {
                constructor(x, y, type, isBuilt = true) {
                    this.x = (x * TILE_SIZE) + (TILE_SIZE / 2);
                    this.y = (y * TILE_SIZE) + (TILE_SIZE / 2);
                    this.type = type;
                    this.isBuilt = isBuilt; // æ˜¯å¦å·²å»ºé€ å®Œæˆ (è—åœ–æ¨¡å¼)
                    const specs = towerTypes[type];
                    this.emoji = specs.emoji;
                    this.range = specs.range;
                    this.fireRate = specs.fireRate;
                    this.projectileSpec = specs.projectile;
                    this.cost = specs.cost;
                    this.fireCooldown = 0;
                    this.target = null;
                }

                findTarget() {
                    // AI é‚è¼¯ï¼šå„ªå…ˆæ”»æ“Šè·¯å¾‘ä¸Šèµ°æœ€é  (waypointIndex æœ€å¤§) çš„æ•µäºº
                    let bestTarget = null;
                    let maxWaypointIndex = -1;
                    let minDistanceToNext = Infinity;

                    for (const enemy of enemies) {
                        const distance = Math.sqrt(Math.pow(this.x - enemy.x, 2) + Math.pow(this.y - enemy.y, 2));

                        if (distance <= this.range) {
                            if (enemy.waypointIndex > maxWaypointIndex) {
                                maxWaypointIndex = enemy.waypointIndex;
                                bestTarget = enemy;
                                if (enemy.waypointIndex < waypoints.length) {
                                    const nextWp = waypoints[enemy.waypointIndex];
                                    const dx = nextWp.x - enemy.x;
                                    const dy = nextWp.y - enemy.y;
                                    minDistanceToNext = Math.sqrt(dx * dx + dy * dy);
                                } else {
                                    minDistanceToNext = Infinity;
                                }
                            } else if (enemy.waypointIndex === maxWaypointIndex) {
                                if (enemy.waypointIndex < waypoints.length) {
                                    const nextWp = waypoints[enemy.waypointIndex];
                                    const dx = nextWp.x - enemy.x;
                                    const dy = nextWp.y - enemy.y;
                                    const distToNext = Math.sqrt(dx * dx + dy * dy);
                                    if (distToNext < minDistanceToNext) {
                                        minDistanceToNext = distToNext;
                                        bestTarget = enemy;
                                    }
                                }
                            }
                        }
                    }
                    this.target = bestTarget;
                }

                update() {
                    if (!this.isBuilt) return; // è—åœ–ä¸æœƒæ”»æ“Š

                    if (this.fireCooldown > 0) {
                        this.fireCooldown--;
                    }
                    if (this.target) {
                        const distance = Math.sqrt(Math.pow(this.x - this.target.x, 2) + Math.pow(this.y - this.target.y, 2));
                        if (this.target.health <= 0 || distance > this.range) {
                            this.target = null;
                        }
                    }
                    if (!this.target) {
                        this.findTarget();
                    }
                    if (this.target && this.fireCooldown <= 0) {
                        this.shoot();
                        this.fireCooldown = this.fireRate;
                    }
                }

                draw() {
                    ctx.font = '28px Arial';
                    
                    if (!this.isBuilt) {
                        // ç¹ªè£½è—åœ–æ•ˆæœ (åŠé€æ˜ + ç°è‰²)
                        ctx.globalAlpha = 0.4;
                        ctx.fillStyle = '#aaa';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, TILE_SIZE/2 - 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'black';
                    }

                    ctx.fillText(this.emoji, this.x - TILE_SIZE / 2 + 5, this.y + TILE_SIZE / 2 - 8);

                    if (!this.isBuilt) {
                        ctx.globalAlpha = 1.0;
                    }

                    if (placingTowerType && this.x === mouse.x && this.y === mouse.y) {
                         ctx.beginPath();
                         ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                         ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                         ctx.stroke();
                    }
                }

                shoot() {
                    projectiles.push(new Projectile(this.x, this.y, this.target, this.projectileSpec));
                }
            }

            // å­å½ˆ
            class Projectile {
                constructor(x, y, target, spec) {
                    this.x = x;
                    this.y = y;
                    this.target = target;
                    this.speed = spec.speed;
                    this.damage = spec.damage;
                    this.color = spec.color;
                    this.radius = 4;
                    this.splashRadius = spec.splashRadius || 0;
                }

                update() {
                    if (!this.target || this.target.health <= 0) {
                        this.destroy();
                        return;
                    }

                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < this.speed || distance < this.radius) {
                        this.hitTarget();
                        return;
                    }

                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }

                hitTarget() {
                    if (this.splashRadius > 0) {
                        explosions.push(new Explosion(this.x, this.y, this.splashRadius));
                        for (const enemy of enemies) {
                            const dist = Math.sqrt(Math.pow(this.x - enemy.x, 2) + Math.pow(this.y - enemy.y, 2));
                            if (dist <= this.splashRadius) {
                                enemy.takeDamage(this.damage);
                            }
                        }
                    } else {
                        if (this.target) {
                            this.target.takeDamage(this.damage);
                        }
                    }
                    this.destroy();
                }

                destroy() {
                    const index = projectiles.indexOf(this);
                    if (index > -1) {
                        projectiles.splice(index, 1);
                    }
                }
            }
            
            // çˆ†ç‚¸æ•ˆæœ
            class Explosion {
                constructor(x, y, radius) {
                    this.x = x;
                    this.y = y;
                    this.radius = radius;
                    this.maxRadius = radius;
                    this.duration = 15;
                    this.life = this.duration;
                }
                
                update() {
                    this.life--;
                    if(this.life <= 0) {
                        const index = explosions.indexOf(this);
                        if (index > -1) {
                            explosions.splice(index, 1);
                        }
                    }
                }
                
                draw() {
                    const opacity = this.life / this.duration;
                    this.radius = this.maxRadius * (1 - opacity);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 165, 0, ${opacity * 0.5})`;
                    ctx.fill();
                }
            }

            // éŠæˆ²é‚è¼¯
            let waveInProgress = false;

            function startWave() {
                if (waveInProgress) return;
                waveInProgress = true;
                wave++;
                startWaveBtn.disabled = true;

                const enemyCount = 10 + wave * 3;
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => {
                        if (gameRunning) {
                            enemies.push(new Enemy());
                        }
                    }, i * 500);
                }

                const checkWaveEnd = setInterval(() => {
                    if (enemies.length === 0 && gameRunning) {
                        waveInProgress = false;
                        startWaveBtn.disabled = false;
                        clearInterval(checkWaveEnd);
                    }
                }, 1000);
            }

            function updateUI() {
                moneyEl.textContent = `ğŸ’° é‡‘éŒ¢: ${money}`;
                livesEl.textContent = `â¤ï¸ ç”Ÿå‘½: ${lives}`;
                waveEl.textContent = `ğŸŒŠ æ³¢æ•¸: ${wave}`;
                
                // æ›´æ–°æŒ‰éˆ•æ¨£å¼
                buyTowerBtns.forEach(btn => {
                    const type = btn.dataset.type;
                    const specs = towerTypes[type];
                    const isUnlocked = unlockedTowers[type];
                    const unlockProgress = unlockingTimers[type];
                    
                    // é‡è¨­ class
                    btn.className = 'tower-buy'; 
                    // æ¸…é™¤å…§éƒ¨ HTML è®“æˆ‘å€‘å¯ä»¥å®Œå…¨é‡å¯«
                    btn.innerHTML = '';
                    
                    if (!isUnlocked) {
                        if (unlockProgress > 0) {
                            // è§£é–ä¸­ç‹€æ…‹
                            btn.classList.add('unlocking');
                            
                            // è¨ˆç®—é€²åº¦ç™¾åˆ†æ¯”
                            const totalTime = specs.unlockTime;
                            const percent = ((totalTime - unlockProgress) / totalTime) * 100;
                            const remainingSeconds = Math.ceil(unlockProgress / 60);
                            
                            // å‰µå»ºé€²åº¦æ¢èƒŒæ™¯
                            const progressBg = document.createElement('div');
                            progressBg.className = 'progress-bar';
                            progressBg.style.width = `${percent}%`;
                            btn.appendChild(progressBg);
                            
                            // æ–‡å­—
                            const textSpan = document.createElement('span');
                            textSpan.textContent = `â³ ç ”ç™¼ä¸­... ${remainingSeconds}s`;
                            textSpan.style.position = 'relative';
                            textSpan.style.zIndex = '2';
                            btn.appendChild(textSpan);
                            
                        } else {
                            // é–å®šç‹€æ…‹
                            btn.classList.add('locked');
                            btn.textContent = `ğŸ”“ è§£é– ${specs.emoji} (${specs.unlockCost}é‡‘)`;
                            
                            if (money < specs.unlockCost) {
                                btn.classList.add('expensive');
                            }
                        }
                    } else {
                        // å·²è§£é–ç‹€æ…‹
                        btn.textContent = `è³¼è²· ${specs.emoji} (${specs.cost}é‡‘)`;
                        
                        if (money < specs.cost) {
                            btn.classList.add('expensive');
                        }
                        
                        if (placingTowerType === type) {
                            btn.classList.add('selected');
                        }
                    }
                });
            }

            function showMessage(text, isSuccess = false) {
                messageEl.textContent = text;
                messageEl.className = isSuccess ? 'success' : '';
                messageEl.style.opacity = 1;
                setTimeout(() => {
                    messageEl.style.opacity = 0;
                }, 2000);
            }

            function gameOver() {
                if (!gameRunning) return;
                gameRunning = false;
                popupEl.textContent = "éŠæˆ²çµæŸï¼";
                popupEl.style.display = 'block';
            }

            // è‡ªå‹•å»ºé€ é‚è¼¯ (æª¢æŸ¥å·²æ”¾ç½®çš„è—åœ–)
            function checkBlueprints() {
                // æ‰¾å‡ºæ‰€æœ‰å°šæœªå»ºé€ çš„å¡” (è—åœ–)
                const blueprints = towers.filter(t => !t.isBuilt);
                
                for (const bp of blueprints) {
                    // å¦‚æœé‡‘éŒ¢è¶³å¤ ï¼Œå°‡å…¶è½‰ç‚ºå¯¦é«”
                    if (money >= bp.cost) {
                        money -= bp.cost;
                        bp.isBuilt = true;
                        
                        // å‰µå»ºä¸€å€‹å»ºé€ ç‰¹æ•ˆ (å°çˆ†ç‚¸)
                        explosions.push(new Explosion(bp.x, bp.y, 20));
                        updateUI();
                        break; 
                    }
                }
            }
            
            // æ›´æ–°è§£é–é€²åº¦
            function updateUnlocking() {
                let needsUpdate = false;
                for (const type in unlockingTimers) {
                    if (unlockingTimers[type] > 0) {
                        unlockingTimers[type]--;
                        needsUpdate = true; // å› ç‚º UI éœ€è¦é¡¯ç¤ºé€²åº¦æ¢ï¼Œæ‰€ä»¥æ¯å¹€æ›´æ–°æœ‰é»é »ç¹ï¼Œå¯ä»¥å„ªåŒ–
                        
                        // è§£é–å®Œæˆ
                        if (unlockingTimers[type] <= 0) {
                            unlockingTimers[type] = 0;
                            unlockedTowers[type] = true;
                            
                            showMessage(`${towerTypes[type].emoji} ç ”ç™¼å®Œæˆï¼`, true);
                            explosions.push(new Explosion(canvas.width/2, canvas.height/2, 200)); // å¤§æ…¶ç¥ç…™ç«
                            needsUpdate = true;
                        }
                    }
                }
                if (needsUpdate && frameCount % 10 === 0) { // ç¨å¾®é™ä½UIæ›´æ–°é »ç‡
                     updateUI();
                }
            }

            // åˆ‡æ›è‡ªå‹•å»ºé€ 
            autoBuildBtn.addEventListener('click', () => {
                isAutoBuildOn = !isAutoBuildOn;
                autoBuildBtn.textContent = isAutoBuildOn ? "ğŸ¤– è‡ªå‹•å»ºé€ : é–‹" : "ğŸ¤– è‡ªå‹•å»ºé€ : é—œ";
                if (isAutoBuildOn) {
                    autoBuildBtn.classList.add('active');
                } else {
                    autoBuildBtn.classList.remove('active');
                }
            });


            // æ»‘é¼ /æ”¾ç½®é‚è¼¯
            let placingTowerType = null;
            let mouse = { x: 0, y: 0, gridX: 0, gridY: 0 };

            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const x = (evt.clientX - rect.left) * scaleX;
                const y = (evt.clientY - rect.top) * scaleY;
                return { x, y };
            }

            canvas.addEventListener('mousemove', (e) => {
                const pos = getMousePos(e);
                mouse.x = pos.x;
                mouse.y = pos.y;
                mouse.gridX = Math.floor(mouse.x / TILE_SIZE);
                mouse.gridY = Math.floor(mouse.y / TILE_SIZE);
            });

            canvas.addEventListener('click', () => {
                if (!placingTowerType) return;

                const specs = towerTypes[placingTowerType];
                const cost = specs.cost;
                
                // åªè¦æ ¼å­æ˜¯ç©ºçš„å°±å¯ä»¥æ”¾ç½® (ä¸ç®¡éŒ¢å¤ ä¸å¤ )
                if (canPlaceTower(mouse.gridX, mouse.gridY)) {
                    // æª¢æŸ¥è—åœ–ä¸Šé™
                    const currentBlueprints = towers.filter(t => !t.isBuilt).length;
                    
                    // æ±ºå®šæ˜¯ç›´æ¥å»ºé€ é‚„æ˜¯æ”¾è—åœ–
                    let builtNow = false;
                    
                    if (money >= cost && !isAutoBuildOn) {
                        money -= cost;
                        builtNow = true;
                    } else {
                        builtNow = false; // è®Šæˆè—åœ–
                    }

                    // å¦‚æœæ˜¯è—åœ–ï¼Œæª¢æŸ¥æ˜¯å¦è¶…éä¸Šé™
                    if (!builtNow && currentBlueprints >= MAX_BLUEPRINTS) {
                        showMessage(`è—åœ–æ•¸é‡å·²é”ä¸Šé™ (${MAX_BLUEPRINTS}å€‹)ï¼`);
                        return;
                    }

                    towers.push(new Tower(mouse.gridX, mouse.gridY, placingTowerType, builtNow));
                    grid[mouse.gridY][mouse.gridX] = 2; 
                    
                    updateUI();
                }
            });
            
            function canPlaceTower(gridX, gridY) {
                if (!grid[gridY] || grid[gridY][gridX] === undefined) return false;
                return grid[gridY][gridX] === 0;
            }

            function drawPlacementPreview() {
                if (!placingTowerType) return;

                const gridX = mouse.gridX;
                const gridY = mouse.gridY;
                
                if (gridX < 0 || gridX >= COLS || gridY < 0 || gridY >= ROWS) return;

                const x = (gridX * TILE_SIZE) + (TILE_SIZE / 2);
                const y = (gridY * TILE_SIZE) + (TILE_SIZE / 2);
                const specs = towerTypes[placingTowerType];

                ctx.globalAlpha = 0.5;
                ctx.font = '28px Arial';
                ctx.fillText(specs.emoji, x - TILE_SIZE / 2 + 5, y + TILE_SIZE / 2 - 8);
                
                ctx.beginPath();
                ctx.arc(x, y, specs.range, 0, Math.PI * 2);
                
                if (canPlaceTower(gridX, gridY)) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                } else {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                }
                ctx.stroke();
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            // æŒ‰éˆ•äº‹ä»¶
            startWaveBtn.addEventListener('click', startWave);

            buyTowerBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const type = btn.dataset.type;
                    const specs = towerTypes[type];
                    
                    // æª¢æŸ¥æ˜¯å¦é–å®š
                    if (!unlockedTowers[type]) {
                        // å¦‚æœæ­£åœ¨è§£é–ä¸­ï¼Œä»€éº¼éƒ½ä¸åš
                        if (unlockingTimers[type] > 0) return;

                        // å˜—è©¦é–‹å§‹è§£é–
                        if (money >= specs.unlockCost) {
                            money -= specs.unlockCost;
                            // é–‹å§‹è¨ˆæ™‚
                            unlockingTimers[type] = specs.unlockTime;
                            
                            // ç«‹å³æ›´æ–° UI
                            updateUI();
                        } else {
                            showMessage('é‡‘éŒ¢ä¸è¶³ä»¥è§£é–ï¼');
                        }
                    } else {
                        // æ­£å¸¸è³¼è²·é‚è¼¯
                        if (placingTowerType === type) {
                            placingTowerType = null;
                        } else {
                            placingTowerType = type;
                        }
                        updateUI();
                    }
                });
            });
            
            // éŠæˆ²ä¸»å¾ªç’°
            let frameCount = 0; // ç”¨æ–¼è¨ˆæ•¸
            
            function gameLoop() {
                if (!gameRunning) return;

                // 1. æ¸…é™¤ç•«å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 2. ç¹ªè£½èƒŒæ™¯
                drawBackground();

                // è‡ªå‹•å»ºé€ é‚è¼¯ (æ¯ 10 å¹€æª¢æŸ¥ä¸€æ¬¡)
                frameCount++;
                if (isAutoBuildOn && frameCount % 10 === 0) {
                    checkBlueprints();
                }
                
                // æ›´æ–°è§£é–è¨ˆæ™‚
                updateUnlocking();

                // 3. æ›´æ–°èˆ‡ç¹ªè£½
                // æ•µäºº
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (enemies[i]) {
                        enemies[i].update();
                    }
                    if (enemies[i]) {
                        enemies[i].draw();
                    }
                }

                // å¡” (åŒ…å«è—åœ–)
                towers.forEach(tower => {
                    tower.update();
                    tower.draw();
                });

                // å­å½ˆ
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    if (projectiles[i]) {
                        projectiles[i].update();
                    }
                    if (projectiles[i]) {
                        projectiles[i].draw();
                    }
                }
                
                // çˆ†ç‚¸
                for (let i = explosions.length - 1; i >= 0; i--) {
                     if (explosions[i]) {
                        explosions[i].update();
                    }
                    if (explosions[i]) {
                        explosions[i].draw();
                    }
                }

                // ç¹ªè£½æ”¾ç½®é è¦½
                drawPlacementPreview();

                // 4. æ›´æ–° UI (å› ç‚ºæœ‰é€²åº¦æ¢ï¼Œæˆ‘å€‘åœ¨ updateUnlocking è£¡è™•ç†äº†éƒ¨åˆ† UI æ›´æ–°ï¼Œé€™è£¡åƒ…åšåŸºç¤æ›´æ–°ä»¥é˜²è¬ä¸€)
                // updateUI(); // è¨»è§£æ‰ï¼Œé¿å…éåº¦æ¸²æŸ“ï¼Œæ”¹ç”±äº‹ä»¶é©…å‹• + updateUnlocking æ§åˆ¶

                // 5. å¾ªç’°
                requestAnimationFrame(gameLoop);
            }

            // å•Ÿå‹•éŠæˆ²
            updateUI();
            drawBackground();
            gameLoop();
        });
    </script>
</body>
</html>